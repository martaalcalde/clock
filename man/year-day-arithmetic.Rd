% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/gregorian-year-day.R
\name{year-day-arithmetic}
\alias{year-day-arithmetic}
\alias{add_years.clock_year_day}
\title{Arithmetic: year-day}
\usage{
\method{add_years}{clock_year_day}(x, n, ...)
}
\arguments{
\item{x}{\verb{[clock_year_day]}

A year-day vector.}

\item{n}{\verb{[integer / clock_duration]}

An integer vector to be converted to a duration, or a duration
corresponding to the arithmetic function being used. This corresponds
to the number of duration units to add. \code{n} may be negative to subtract
units of duration.}

\item{...}{These dots are for future extensions and must be empty.}
}
\value{
\code{x} after performing the arithmetic.
}
\description{
These are year-day methods for the
\link[=clock-arithmetic]{arithmetic generics}.
\itemize{
\item \code{add_years()}
}

Notably, \emph{you cannot add days to a year-day}. For day-based arithmetic,
first convert to a time point with \code{\link[=as_naive_time]{as_naive_time()}} or \code{\link[=as_sys_time]{as_sys_time()}}.
}
\details{
\code{x} and \code{n} are recycled against each other using
\link[vctrs:theory-faq-recycling]{tidyverse recycling rules}.
}
\examples{
x <- year_day(2019, 10)

add_years(x, 1:5)

# A valid day in a leap year
y <- year_day(2020, 366)
y

# Adding 1 year to `y` generates an invalid date
y_plus <- add_years(y, 1)
y_plus

# Invalid dates are fine, as long as they are eventually resolved
# by either manually resolving, or by calling `invalid_resolve()`

# Resolve by returning the previous / next valid moment in time
invalid_resolve(y_plus, invalid = "previous")
invalid_resolve(y_plus, invalid = "next")

# Manually resolve by setting to the last day of the year
invalid <- invalid_detect(y_plus)
y_plus[invalid] <- set_day(y_plus[invalid], "last")
y_plus
}
